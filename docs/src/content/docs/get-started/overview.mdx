---
title: Aspire Overview
description: Learn how Aspire simplifies the development, deployment, and debugging of distributed applications.
lastUpdated: true
---

import { Aside, Code, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Kbd } from 'starlight-kbd/components'
import IconAside from '../../../components/IconAside.astro';
import Architecture from './three-tier-architecture.svg';

Aspire streamlines building, running, debugging, and deploying distributed apps. Picture your app as a set of services, databases, and frontends—when they're deployed, they all work together seamlessly, but every time you develop them they need to be individually started and connected. With Aspire, you get a unified toolchain that eliminates complex configs and makes local debugging effortless. Instantly launch and debug your entire app with a single command. Ready to deploy? Aspire lets you publish anywhere—Kubernetes, the cloud, or your own servers. It's also fully extensible, so you can integrate your favorite tools and services with ease.

## The AppHost

Aspire's **AppHost** is where you define your app's services and dependencies in code—no complex configs required. Easily map out your architecture and let Aspire handle the local orchestration, so you can focus on building features.

A simple example might represent a common three-tier architecture with a frontend that depends on an API, which in turn connects to a database:

<Architecture />

This could be represented in the AppHost as shown in the following code:

export const ts = `
import { createBuilder } from "./.modules/distributed-application";

const builder = createBuilder();

// Add database service to orbit
const postgres = builder.addPostgres("db").addDatabase("appdata");

// Add API service and reference the database
const api = builder.addProject("api", "../api/ApiService")
  .withReference(postgres);

// Add frontend service and reference the API
const frontend = builder.addNpmApp("frontend", "../frontend")
  .withHttpEndpoint({ env: "PORT", targetPort: 3000 })
  .withNpmPackageInstallation()
  .withReference(api);

builder.build().run();
`;

export const py = `
from aspire import create_builder

builder = create_builder()

# Add database service to orbit
postgres = builder.add_postgres("db").add_database("appdata")

# Add API service and reference the database
api = builder.add_project("api", "../api/api_service.py") \\
       .with_reference(postgres)

# Add frontend service and reference the API
builder.add_npm_app("frontend", "../frontend") \\
          .with_http_endpoint(env="PORT", target_port=3000) \\
          .with_npm_package_installation() \\
          .with_reference(api)

# Launch your services into orbit
builder.build().run()
`;

export const cs = `
var builder = DistributedApplication.CreateBuilder(args);

// Add database service to orbit
var postgres = builder.AddPostgres("db").AddDatabase("appdata");

// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
                 .WithReference(postgres);

// Add frontend service and reference the API
var frontend = builder.AddNpmApp("frontend", "../frontend")
                      .WithHttpEndpoint(env: "PORT", targetPort: 3000)
                      .WithNpmPackageInstallation()
                      .WithReference(api);

builder.Build().Run();
`;

<Tabs>
  <TabItem label="TypeScript" icon="seti:typescript">
	  <Code code={ts} lang="ts" frame='terminal' title='index.ts' />
  </TabItem>

  <TabItem label="Python" icon="seti:python">
	  <Code code={py} lang="python" frame='terminal' title='__main.py__' />
  </TabItem>

  <TabItem label="C#" icon="seti:c-sharp">
	  <Code code={cs} lang="cs" frame='terminal' title='AppHost.cs' />
  </TabItem>
</Tabs>

Regardless of the language you choose, Aspire provides a consistent way to define your app's architecture. You can easily add services, set up dependencies, and configure how they interact—all in a straightforward, code-first manner.

## Modeled as Resources

Aspire makes it easy to define everything your app needs—frontends, APIs, databases, and more—using the unified **AppHost** model. Just describe your resources in code, and Aspire handles the connections for you. Resources can include:

- AI Services
- Caches
- Containers
- Databases
- Executables
- Frameworks
- Messaging Services
- Projects
- Storage

One resource can depend on another, and Aspire automatically wires them together. This means you can focus on building your app without worrying about the underlying infrastructure.

<IconAside type="tip" icon="puzzle" title="Explore Integrations">
    Check out the <a href="../../integrations/gallery">Integrations Gallery</a> to discover pre-built resources and services you can easily add to your app.
</IconAside>

Under-the-hood, every integration is either a **Container** or **Executable**, meaning you can add _any_ container image, codebase, script, or cloud resource to your AppHost.


<Aside type="tip">
  Creating reusable Aspire integrations is just like creating a reusable UI component. It can be as simple or complex as you need, and is fully shareable. Learn more about creating custom resources for Aspire.
</Aside>

## Reusable Composition

When you compose your distributed app in Aspire's **AppHost**, you're not just defining services for local development and orchestration—you're also setting up the foundation for deployment. The same composition you use to run and debug locally is leveraged when you publish your app, ensuring consistency from development through to production. Likewise, Aspire doesn't get in the way of your existing deployment workflows.
