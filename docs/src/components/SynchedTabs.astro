---
const { id: groupId } = Astro.props;
---

<style>
  .synced-tabs .starlight-tabs {
    margin: 0;
  }
  
  .synced-tabs .starlight-tabs [role="tablist"] {
    border-bottom: 1px solid var(--sl-color-gray-5);
  }
  
  .synced-tabs .starlight-tabs [role="tab"] {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border: 1px solid transparent;
    border-bottom: none;
    background: var(--sl-color-gray-6);
    user-select: none;
  }
  
  .synced-tabs .starlight-tabs [role="tab"][aria-selected="true"] {
    border-color: var(--sl-color-gray-5) var(--sl-color-gray-5) transparent;
    background: var(--sl-color-bg);
    font-weight: bold;
  }
</style>

<div class="synced-tabs" data-group-id={groupId}>
  <slot />
</div>

<script>
  (() => {
    // Flag to prevent infinite loops during synchronization
    let isSynchronizing = false;

    // Function to get URL parameters
    function getUrlParams() {
      return new URLSearchParams(window.location.search);
    }

    // Function to update URL parameter
    function updateUrlParam(groupId: string, tabLabel: string) {
      // Always update URL on user clicks, but not during initial URL-based activation
      const url = new URL(window.location.href);
      url.searchParams.set(groupId, tabLabel.toLowerCase());
      
      // Update URL without triggering a page reload
      window.history.replaceState({}, '', url);
    }

    // Function to get tab selection from URL
    function getTabFromUrl(groupId: string) {
      const params = getUrlParams();
      return params.get(groupId);
    }

    // Function to activate a tab by label
    function activateTabByLabel(container: Element, tabLabel: string) {
      const starlightTabs = container.querySelector('starlight-tabs');
      if (!starlightTabs) return false;

      const tabButtons = starlightTabs.querySelectorAll('[role="tab"]');
      
      for (const button of tabButtons) {
        const buttonLabel = button.textContent?.trim();
        if (buttonLabel?.toLowerCase() === tabLabel.toLowerCase()) {
          // Directly trigger click without setting sync flag to allow normal event flow
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          button.dispatchEvent(clickEvent);
          
          return true;
        }
      }
      return false;
    }

    // Function to initialize synced tabs
    function initializeSynchedTabs() {
      // Find all synced-tabs containers
      document.querySelectorAll('.synced-tabs[data-group-id]').forEach(container => {
        const groupId = container.getAttribute('data-group-id');
        if (!groupId) return;

        // Find the Starlight tabs component within this container
        const starlightTabs = container.querySelector('starlight-tabs');
        if (!starlightTabs) return;

        // Check if already initialized
        if (starlightTabs.hasAttribute('data-synced-initialized')) return;
        starlightTabs.setAttribute('data-synced-initialized', 'true');

        // Get all tab buttons (they are <a> elements with role="tab")
        const tabButtons = starlightTabs.querySelectorAll('[role="tab"]');

        if (tabButtons.length === 0) return;

        // Add click listeners to synchronize tabs
        tabButtons.forEach((button) => {
          button.addEventListener('click', (e) => {
            // If we're already synchronizing, don't create a loop
            if (isSynchronizing) return;

            const tabLabel = button.textContent?.trim();
            if (!tabLabel) return;

            // Set the synchronizing flag
            isSynchronizing = true;

            // Update URL parameter immediately
            updateUrlParam(groupId, tabLabel);

            // Small delay to let Starlight handle the click first
            setTimeout(() => {
              // Synchronize all tab groups with the same groupId
              document.querySelectorAll(`.synced-tabs[data-group-id="${groupId}"]`).forEach(syncContainer => {
                if (syncContainer === container) return; // Skip the clicked container

                const syncStarlightTabs = syncContainer.querySelector('starlight-tabs');
                if (!syncStarlightTabs) return;

                const syncTabButtons = syncStarlightTabs.querySelectorAll('[role="tab"]');

                // Find the matching tab by label
                syncTabButtons.forEach((syncButton) => {
                  const syncTabLabel = syncButton.textContent?.trim();
                  if (syncTabLabel === tabLabel) {
                    // Trigger a click event on the matching tab
                    const clickEvent = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    syncButton.dispatchEvent(clickEvent);
                  }
                });
              });

              // Reset the synchronizing flag after a short delay
              setTimeout(() => {
                isSynchronizing = false;
              }, 50);
            }, 10);
          });
        });

        // Check if there's a URL parameter for this group and apply it AFTER event listeners are set up
        const urlTabSelection = getTabFromUrl(groupId);
        if (urlTabSelection) {
          // Use setTimeout to ensure this happens after all initialization
          setTimeout(() => {
            // Temporarily disable synchronization to prevent loops during URL-based activation
            const wasSynchronizing = isSynchronizing;
            isSynchronizing = true;
            
            activateTabByLabel(container, urlTabSelection);
            
            // Reset sync flag after a delay
            setTimeout(() => {
              isSynchronizing = wasSynchronizing;
            }, 100);
          }, 50);
        }
      });
    }

    // Initialize immediately if DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeSynchedTabs);
    } else {
      initializeSynchedTabs();
    }

    // Also use MutationObserver to catch dynamically added content
    const observer = new MutationObserver((mutations) => {
      let shouldReinitialize = false;
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as Element;
              if (element.querySelector && (element.tagName === 'STARLIGHT-TABS' || element.querySelector('starlight-tabs'))) {
                shouldReinitialize = true;
              }
            }
          });
        }
      });
      if (shouldReinitialize) {
        setTimeout(initializeSynchedTabs, 100);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Cleanup observer when page unloads
    window.addEventListener('beforeunload', () => {
      observer.disconnect();
    });
  })();
</script>
